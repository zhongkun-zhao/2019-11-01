<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
<script>

     /*
        let {key1,key2} = {key1:val1,key2:val2}

        在声明的时候使用块声明，块中放对象的key值，这里的key值一定要
        和解构对象的key值名字要一致

        如果要取别名，使用:新定义的名字即可
            let {key1:k,key2} = {key1:val1,key2:val2}

        此时key1已经访问不到了，要访问就报错，只能访问k，k就代表key1，
        名字跟声明变量规则一致

        如果加了:不报错，那么可以先解构一次，再重命名
            let {
                f,  //先把f解构出来，这样就可以访问f了
                f:x
            } = {
               f:{
                    name:'11',
                    age:22
               }
            }

    */
   /*  let objhdjksdjks = {
        type: "sug", 
        sa: "s_2",
        q: "猪肉为什么涨价",
        s:"生杀母猪"
    }    
    let {type:t,q,s} = objhdjksdjks;
    // console.log(type,q,s);//报错 
    console.log(t);//sug
    console.log(objhdjksdjks.t);//undefined
    console.log(objhdjksdjks.type);//sug

    console.log(objhdjksdjks.q);//猪肉为什么涨价
    console.log(objhdjksdjks.s);//生杀母猪
    console.dir(console); */

    
   //    let obj = {
    //     p: [
    //         'Hello',
    //         {
    //             y: 'World',
    //             z:{
    //                 x:[
    //                     {
    //                         j:0
    //                     }
    //                 ]
    //             }
    //         }
    //     ]
    // };
    // let {p:[x,{y,z:{x:[{j}]}}]} = obj

    // console.log(j);

  /*   
    const node = {
        loc: {
            start: {
                line: 1,
                column: 5
            }
        }
    };

    let { loc, loc: { start }, loc: { start: { column }} } = node;

    console.log(column);//5
 */
    
    /* let {
        f,
        f:x
    } = {
        f:{
            name:'11',
            age:22
        }
    }

    console.log(f)//{name: "11", age: 22} 
    */
   
    let obj = {};
    let arr = [];
    // foo->123  -> obj.prop = 123 
    ({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });
    console.log(obj,arr[0]);
   
    /*
     var {x, y = 5} = {x: 1};
    console.log(x,y);//1 5 
    */

  
  // unction move ({x, y} = { x: 0, y: 0 }) {
        //return [x, y];
   // }
    /**
        传了对象那么就按照传的对象来解析，不会按照默认的来解析 
    **/
    //const {log} = console;
    //log(move({x: 3, y: 8}));  //3,8
   // log( move( {x: 3} )); //3,undefined
   // log( move({}));//undefined,undefined
   // log(move());//0,0 
   
    
</script>
</body>
</html>