<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
<script>
/*
  JS按理说从上往下解读代码  单线程。（同一时间，只能做一件事情）

  事件调用 ->把任务交给了事件引擎（所有的js事件全部都是异步的）

    同步：
      代码从上往下依次执行，如果一个地方卡住了，下面的代码就不执行了。
    异步：
      虽然代码从上往下依次执行，如果有个地方卡住了，不会阻止代码行下执行。

      定时器、所有事件、promise、
    异步操作不利于进行维护开发，同步操作利于维护开发。

    js先执行主线程的代码，如果主线程有异步代码，比如定时器，promise或者事件
    那么会把异步代码放到异步队列中存储，当异步代码的条件成立的时候，把异步代码压入到主线程中执行，压入的方式是如果有微任务就先执行微任务，执行完微任务再执行宏任务，当主线程空闲的时候执行压入的代码，执行完之后再从异步队列中压入异步代码到主线程中，这个过程叫事件循环。

    promise是解决异步编程顺序问题（也就是，说让异步的代码同步执行）

    注意的是执行完微任务是第一层的,如果在宏任务中开个微任务，那么先执行宏任务，再执行宏任务中的微任务

    setTimeout(function(){
          promise()
      })

    异步的操作是不容易进行维护开发的，同步操作才利于维护开发（上面的代码执行完才会执行下面的，有序的）

    promise是解决异步编程顺序问题的（也就是说，让异步的代码同步执行）

   
 */
/*  var a = 10;
 (function a(){
     console.log(a);
      a=20;
  //函数自执行一旦有名字 打印这个名字，就是这个函数 无论怎么赋值都不会改变。 
  console.dir(a);
    
     console.log(a);   
 }()) */


let a = 10;
setTimeout(() => {
    console.log(a,'2秒');
},2000);

setTimeout(() => {
    console.log(a,'定时器'); 
},0);

//promise是个异步
let p = new Promise((rej,res)=>{
  rej(5);
});

p.then((d)=>{
    console.log(d,'promise');
});
</script>
</body>
</html>