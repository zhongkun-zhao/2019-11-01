# promise
- JS按理说从上往下解读代码  单线程。（同一时间，只能做一件事情）
- 事件调用 ->把任务交给了事件引擎（所有的js事件全部都是异步的）
## 同步异步
-  同步：
      代码从上往下依次执行，如果一个地方卡住了，下面的代码就不执行了。
- 异步：
      虽然代码从上往下依次执行，如果有个地方卡住了，不会阻止代码行下执行。
-  异步操作不利于进行维护开发，同步操作利于维护开发。

###  js先执行主线程的代码，如果主线程有异步代码，比如定时器，promise或者事件那么会把异步代码放到异步队列中存储，当异步代码的条件成立的时候，把异步代码压入到主线程中执行，压入的方式是如果有微任务就先执行微任务，执行完微任务再执行宏任务，当主线程空闲的时候执行压入的代码，执行完之后再从异步队列中压入异步代码到主线程中，这个过程叫事件循环。

##  promise是解决异步编程顺序问题（也就是，说让异步的代码同步执行）
- 注意的是执行完微任务是第一层的,如果在宏任务中开个微任务，那么先执行宏任务，再执行宏任务中的微任务
-  异步的操作是不容易进行维护开发的，同步操作才利于维护开发（上面的代码执行完才会执行下面的，有序的）
- promise是解决异步编程顺序问题的（也就是说，让异步的代码同步执行）

## 为什么要用promise？
-  promise解决了异步编程的问题
-  在then里面就走"同步"
- new Promise(function(resolve,reject){
        //主线程
        //当异步代码执行完，通过异步代码的结果去调用resolve或者reject

        //异步代码有可能报错或者错误，如果报错或者错误就执行reject
        //一般都是resolve(放异步的结果)
    });

     它有一个返回值，返回值是promise对象，这个对象有then方法
    then(成功函数,失败函数)
    第一个then  （微任务）
        成功函数里面的参数就是异步的结果

    第二个then （微任务）
        第一个then的返回值

- 此时的知识点需要后期内容的铺垫和若干个异步请求实验总结才能领悟这个promise
-  虽然promise解决了异步编程的问题，但是在then的外面还是异步的
- 没有promise也能进行开发，只不过维护起来麻烦点
- then中包含2个函数，第一个函数是成功之后的回调，第二个函数是失败之后的回调
- finally：不管成功还是失败都会进的回调函数
- 如果代码有可能会报错，下面的代码是不会执行的，如果使用try，catch
- 那么try中的代码报错会进catch，报错是不会影响后面代码执行的
