<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
<script>
    /*
        单例模式:单独的实例
        obj = {
            name:'xx',
            age:19
        }
        单例模式:单独的实例
        高级单例模式:

            let obj = (function(){
                // let obj = {}
                function sum(){
                }
                return {
                    sum:sum
                };
            })()
 
            let obj2 = (function(i){
                function sum(){}
                obj.sum()
                return {
                }
            })(i)
            封闭空间不是闭包，而闭包有封闭空间的功能

            工厂模式:
                function fn(name,age){
                    let obj = {};
                    obj.name = name
                    obj.age = age
                    return obj;
                } 

            面向对象:(谁来做这件事)
               面向对象的特征 :封装、继承、多态

                封装就是归类的过程

                **换了一种编程方式**:把具有相同特征特性的代码归为一类（类）
                把描述这个类的特性(共有属性、方法)挂在这个类的原型下的一种
                编程方式

            面向过程:   
                思考如何把它实现

            new
                函数的一元运算符，只能运算函数 

                1.this变成了实例
                2.默认return实例，如果手动设置了返回值，如果是原始类型的那么还是实例，如果是引用类型的那么返回的就是引用类型
                3.加不加括号都能执行函数，括号主要为了传参
                4.首字母大写

            原型:
                当声明函数的时候，函数天生自带的一个属性
                prototype(key) : {}(val)
                
                prototype下的方法或者属性只能通过两种方式使用:
                    1.给自己的实例化对象使用 new fn().a
                    2.直接使用fn.prototype.a
            原型链:
                实例化对象上都有一个叫做___proto__的属性，
                它的值全等于构造函数的原型

                如果某个原型下没有想要的属性或者方法，那么还会通过
                这个原型下的原型链继续查找，直到找到Object.prototype为止
                因为Object.prototype.__proto__为null

    
    */


/*     function fn(){
    }
    Object.prototype.a = 20
    fn.prototype.a = function(){
        console.log(this); //这里的this是prototype
    };
      //实例下的原型链全等于构造函数下的原型
    console.dir(new fn().__proto__  === fn.prototype); //true
    console.log(fn.prototype)//Object 构造函数的prototype就是一个对象
    console.log(new fn().__proto__.a);
    new fn().__proto__.a();// 这里是等于构造函数下原型调用的这个a执行，这里的this就是这个够着函数的原型
    new fn().a();  //这里是 new fn() 这个实例调用的a执行 所有this 是这个实例 
    
*/

    /*
        实例下的.a -> 实例.__proto__  -> 构造函数的原型(fn.prototype)

        fn.prototype.__proto__ -> Object.prototype -> 
        
        Object.prototype.__proto__ = null


        fn.prototype = {
            __proto__:Object.prototype
        }

        内置类:浏览器自带的类

            所有的类型都是构造函数构造出来的

            string  '',"",``,new String()

            object  {}, new Object()

            function（原型）  new Function（构造函数）

            []

    */
  


</script>
</body>
</html>